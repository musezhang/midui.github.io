{"meta":{"title":"米堆的一亩三分地","subtitle":"米堆的个人博客","description":"web开发，php开发相关技术记录和积累","author":"米堆","url":"https://musezhang.github.io"},"pages":[{"title":"关于我","date":"2017-07-29T08:29:47.000Z","updated":"2017-07-29T08:33:03.000Z","comments":true,"path":"about/index.html","permalink":"https://musezhang.github.io/about/index.html","excerpt":"","text":"I am a PHP programmer working at Weibo."},{"title":"分类","date":"2017-07-29T08:11:05.000Z","updated":"2017-07-29T08:11:29.000Z","comments":true,"path":"categories/index.html","permalink":"https://musezhang.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-07-29T08:08:46.000Z","updated":"2017-07-29T08:10:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://musezhang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"php 多进程","slug":"multi-process-of-php","date":"2018-04-19T15:55:00.000Z","updated":"2018-05-06T08:16:48.000Z","comments":true,"path":"2018/04/19/multi-process-of-php/","link":"","permalink":"https://musezhang.github.io/2018/04/19/multi-process-of-php/","excerpt":"前言最近在工作中遇到了一个php多进程的问题，脚本我是能写的，但是没有深入的了解过相关的内容。这篇就是对php处理多进程的一个简单的整理吧。一搬来说，php都是一个单进程执行的，为了应对web并发请求的问题，我们借助服务器或PHP-FPM实现处理。但php的另一种使用场景是在cli模式下跑脚本或daemon来进行数据处理，这种情况下，就需要php自身对多进程的支持。我们知道php是有很多扩展的，实现php的多进程主要依赖pcntl和posix两种扩展。下面主要针对这两种扩展进行介绍。","text":"前言最近在工作中遇到了一个php多进程的问题，脚本我是能写的，但是没有深入的了解过相关的内容。这篇就是对php处理多进程的一个简单的整理吧。一搬来说，php都是一个单进程执行的，为了应对web并发请求的问题，我们借助服务器或PHP-FPM实现处理。但php的另一种使用场景是在cli模式下跑脚本或daemon来进行数据处理，这种情况下，就需要php自身对多进程的支持。我们知道php是有很多扩展的，实现php的多进程主要依赖pcntl和posix两种扩展。下面主要针对这两种扩展进行介绍。 多进程处理扩展php和进程相关的扩展其实很多的，这些扩展目前来说可以解决我们大多数对进程控制的场景，但很多我们并不经常用。经常用到的主要就是两个，一个PCNTL，一个POSIX。如果想了解的更多，可以参考进程控制扩展 pcntl扩展参考：PCNTL官方说明 扩展说明pcntl扩展提供了一系列进程控制函数来实现进程创建、程序执行、信号处理及进程中断处理。但是这类方法不能用于web服务器环境。 主要函数pcntl控制函数很多，本人基于个人认知，大致分为了一下几类，会重点介绍其中的几个。 进程控制 pcntl_exec( string $path [, array $args [, array $envs ]] )在当前进程空间执行指定程序 path:可执行文件路径 args:传递给程序的参数的字符串数组 envs:要传递给程序作为环境变量的字符串数组 pcntl_fork():创建一个子进程(从当前位置往后是子进程内容)，子进程仅pid和父进程不同返回值：0（当前在子进程中）；-1(创建进程失败)；&gt;0,在父进程中 123456789101112131415&lt;?php$pid = pcntl_fork();//父进程和子进程都会执行下面代码if ($pid == -1) &#123; //错误处理：创建子进程失败时返回-1. die('could not fork');&#125; else if ($pid) &#123; //父进程会得到子进程号，所以这里是父进程执行的逻辑 pcntl_wait($status); //等待子进程中断，防止子进程成为僵尸进程。&#125; else &#123; //子进程得到的$pid为0, 所以这里是子进程执行的逻辑。&#125;?&gt; pcntl_getpriority：查询指定pid进程的优先级int pcntl_getpriority ([ int $pid = getmypid() [, int $process_identifier = PRIO_PROCESS ]] ) pcntl_setpriority: 设置指定pid进程的优先级bool pcntl_setpriority ( int $priority [, int $pid = getmypid() [, int $process_identifier = PRIO_PROCESS ]] ) pcntl_wait：等待或返回fork的子进程状态int pcntl_wait ( int &amp;$status [, int $options = 0 ] )挂起当前进程的执行直到一个子进程退出或接收到一个信号要求中断当前进程或调用一个信号处理函数。 pcntl_waitpid：挂起当前进程的执行直到参数pid指定的进程号的进程退出， 或接收到一个信号要求中断当前进程或调用一个信号处理函数如果pid指定的子进程在此函数调用时已经退出（俗称僵尸进程），此函数 将立刻返回 信号处理 pcntl_alarm(int $seconds):为进程创建闹钟信号，在指定的秒数后向进程发送一个SIGALRM信号 pcntl_async_signals(bool $on = NULL ] )启用/禁用异步信号处理,如果不传参数，返回是否启用了异步信号处理 pcntl_signal_dispatch：调用等待信号的处理器，等待信号的处理器使用pcntl_signal() 创建安装 pcntl_signal_get_handler：获取指定信号的当前处理程序 pcntl_signal：为指定编号的信号安装一个信号处理器bool pcntl_signal ( int $signo , callback $handler [, bool $restart_syscalls = true ] ) signo 信号编号 handler 信号处理器(程序)可以是用户创建的函数或方法的名字，也可以是系统常量 SIG_IGN（译注：忽略信号处理程序）或SIG_DFL（默认信号处理程序）. restart_syscalls:指定当信号到达时系统调用重启是否可用（详见官网说明） pcntl_sigprocmask：用来增加，删除或设置阻塞信号 pcntl_sigtimedwait：带超时机制的信号等待 pcntl_sigwaitinfo：暂停调用脚本的执行直到接收到set 参数中列出的某个信号， 其他： pcntl_errno:函数pcntl_get_last_error()的别名 pcntl_get_last_error：返回最近一次pcntl函数错误的错误码 pcntl_strerror：根据错误编号获取系统错误描述 pcntl_wexitstatus:返回一个中断的子进程的返回代码 pcntl_wifexited:检查子进程状态代码是否代表正常退出。 pcntl_wifsignaled:检查子进程是否是由于某个未捕获的信号退出的。 pcntl_wifstopped:检查子进程当前是否已经停止 pcntl_wstopsig:返回导致子进程停止的信号 pcntl_wtermsig:返回导致子进程中断的信号 应用实例如果不需要涉及到信号量处理相关的内容，那么一个最简单的php多进程脚本代码大致如下：123456789101112131415161718192021222324&lt;?phpfor ($i=0; $i&lt;3; ++$i)&#123; $pids[$i] = pcntl_fork(); if ($pid[$i] == -1)&#123; die (\"cannot fork\" ); &#125; else if ($pid &gt; 0)&#123; echo \"parent continue \\n\"; &#125; else if ($pid == 0) &#123; echo \"child start, pid \", getmypid(), \"\\n\" ; exit (0); &#125;&#125;//对进程进行回收foreach ($pids as $pid)&#123; if($pid) &#123; pcntl_waitpid($pid, $status); &#125;&#125; 特别说明在php多进程脚本中，有几个需要重点理解的点： pcntl_fork的返回值:&gt;0,在父进程中;=0，创建子进程成功，进入子进程;&lt;0(就是-1)创建失败 pcntl_wait和pcntl_waitpid的区别:二者都是挂起进程直到进程退出或中断后进行后续，但是pcntl_wait无法指定pid，所以必须在创建子进程的循环中出现，但是这样会造成脚本变为串行，所以可以使用pcntl_waitpid，在创建完所有的子进程后，对进程进行回收，防止出现僵尸进程(也可能和参数有关，后续调研) 子进程执行的代码是pcntl_fork之后的代码 posix扩展参考 扩展说明POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称.posix扩展包含了定义在 IEEE 1003.1(POSIX.1)标准文档里的函数的接口,(windows不可用，无检测，不需要的情况下建议关闭)所以posix扩展中的一些函数通常会与pcntl扩展配合使用。 主要函数posix_access(string $file[, int $mode = POSIX_F_OK]) :查看用户对文件是否具有指定的权限 $file - 文件名 $mode - 权限，包含：POSIX_F_OK, POSIX_R_OK, POSIX_W_OK, POSIX_X_OK的一个或多个。posix_ctermid():返回当前进程所在的当前控制终端的路径名posix_errno():posix_get_last_error()别名posix_get_last_error():返回最近一次最后的posix函数调用失败的错误号。错误号关联的错误消息，可通过 ‘posix_strerror()’ 来获取posix_strerror(int $errno)：通过给定的错误号，返回关联的POSIX系统错误消息posix_getcwd():取当前脚本的工作目录的绝对路径posix_getegid()返回当前进程的有效用户组IDposix_geteuid()返回当前进程的有效用户IDposix_getgid()返回当前进程的真实用户组IDposix_getuid():返回当前进程的真实用户ID上述四个方法中有效和真实的含义参见inux进程的实际用户ID和有效用户IDposix_getgrgid(int $gid)通过传入组ID，获取给定的用户组的相关信息，返回值如下123456789101112131415161718192021222324Array( [name] =&gt; staff [passwd] =&gt; * [members] =&gt; Array ( [0] =&gt; root [1] =&gt; liyun1 [2] =&gt; zhangyang12 ) [gid] =&gt; 20)``` **posix_getgrnam(string $name)**:通过传入组名称，获取给定的用户组的相关信息,返回值同上 **posix_getgroups()**：获取当前进程的用户组集合 **posix_getlogin()**:返回拥有当前进程的用户的登陆名 **posix_getpgid(int $pid)**:获取指定进程的进程组标识符(进程组id)，返回整数 注意： 该函数不是POSIX函数，但是常见于BSD和System V的系统上。如果系统不支持该函数，在编译时就不会被包含进来。应该提前使用 'function_exists()' 检查，存在再使用 **posix_getpgrp()**:获取当前进程的进程组标识符(进程组id)，返回整数 **posix_getpid()**:获取当前进程的进程标识符(进程id) **posix_getppid()**:获取当前进程的父进程标识符(父进程id) **posix_getpwnam(string $username)**:通过用户名，获取给定用户的信息。返回值如下： Array( [name] =&gt; jack //用户名,和传入参数一致，太长的话会被截断，保留16个字符 [passwd] =&gt; ** //密码 [uid] =&gt; 502 //用户id [gid] =&gt; 20 //用户组id [gecos] =&gt; “jack,,” //一个过时的元素，包含了 ‘,’分隔的用户的全名、办公室电话、办公室号码以及家庭电话号码。大多数的系统上，只有用户的全名有效。 [dir] =&gt; /Users/tom //用户根目录 [shell] =&gt; /bin/bash //可执行的用户的默认shell的绝对路径)12345678910111213141516171819202122**posix_getpwuid(int $uid)**:通过用户id，获取给定用户的信息,返回结果同上 **posix_getrlimit()**:返回一个关于当前资源的软限制和硬限制的信息数组,软硬限制可查询百度**posix_getsid(int $pid)**:返回指定进程的session ID。进程的session ID是会话领导者(session leader)的进程组id **posix_initgroups(string $name, int $base_group_id)**：对指定的用户，计算其组访问列表**posix_isatty(mixed $fd)**:检查文件描述符是否是一个有效的终端类型的设置(是否是tty) **posix_kill(int $pid, int $sig)**:给指定的进程发送一个$sig指定的信号！ 参数： $pid - 进程id $sig - PCNTL信号预定义常量 **posix_mkfifo(string $pathname, int $mode)**:创建一个特殊的FIFO文件，存在于文件系统，并且作为进程的双向通信桥梁(其实就是创建一个先入先出的管道，可以使用文件操作方法写入和读取文件) 参数： $pathname - FIFO文件(管道) $mode - 必须是8进制格式。新创建的FIFO的权限，也依赖于当前的umask()设置。新创建的文件权限是(mode &amp; ~umask) **posix_mknod(string $pathname, int $mode[, int $major = 0[, int $minor = 0]])**：创建一个特殊的或者一般的文件 **posix_setegid(int $gid)**：设置当前进程的有效组ID。这是个特权函数，需要操作系统上具有特殊权限(通常是root权限)，才能执行该函数。 **posix_seteuid(int $uid)**：设置当前进程的有效用户ID。这是个特权函数，需要操作系统上具有特殊权限(通常是root权限)，才能执行该函数。 **posix_setgid(int $gid)**：设置当前进程的真实用户组ID。这是个特权函数，需要操作系统上具有特殊权限(通常是root权限)，才能执行该函数。函数调用的适当的顺序是：首先调用 posix_setgid()，最后调用 posix_setuid()。 **posix_setpgid(int $pid, int $pgid)**:设置指定进程的进程组ID **posix_setrlimit(int $resource, int $softlimit, int $hardlimit)**：设置给定系统资源的软限制和硬限制。 **posix_setsid()**:设置当前进程为session leader(会话领导者) **posix_setuid(int $uid)**:设置当前进程的真实用户ID。这是个特权函数，需要操作系统上具有特殊权限(通常是root权限)，才能执行该函数。 **posix_times()**:获取当前CUP使用信息。警告：函数不可靠，对于高时间(high times)可能返回负值。 Array( [ticks] =&gt; 152559307291 //重启到现在，已经过去的 clock ticks 个数 [utime] =&gt; 5 //当前进程使用的用户时间 [stime] =&gt; 6 //当前进程使用的系统时间 [cutime] =&gt; 0 //当前进程和子进程使用的用户时间 [cstime] =&gt; 0 //当前进程和子进程使用的系统时间)12**posix_ttyname($mixed $fd)**：返回当前打开的文件描述符所在的终端设备的绝对路径 **posix_uname()**:获取系统相关信息(同***uname -a*** 命令)。 Array( [sysname] =&gt; Darwin //操作系统名，如Linux [nodename] =&gt; localhost //系统名称 [release] =&gt; 16.0.0 //操作系统发布版 [version] =&gt; Darwin Kernel Version 16.0.0: Mon Aug 29 17:56:20 PDT 2016; root:xnu-3789.1.32~3/RELEASE_X86_64//操作系统版本 [machine] =&gt; x86_64 //系统平台 [domainname] =&gt; (none) //dns域名)``` 返回值： 返回一个关于系统信息的关联数组 sysname - 操作系统名称(例如：Linux) nodename - 系统名称(例如：valiant) release - 操作系统的发布版(例如：2.6.15-1-686) version - 操作系统版本(例如：#4 Tue Jul 20 17:01:36 MEST 1999) machine - 系统平台(例如：i586) domainname - DNS域名(例如：baidu.com) 参考1.PHP多进程编程2.从0到1优雅的实现PHP多进程管理3.PHP多进程实践4.POSIX函数5.POSIX百度百科","categories":[{"name":"php","slug":"php","permalink":"https://musezhang.github.io/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://musezhang.github.io/tags/php/"},{"name":"多进程","slug":"多进程","permalink":"https://musezhang.github.io/tags/多进程/"}]},{"title":"php中json_encode和json_decode的说明","slug":"json-encode-of-php","date":"2018-03-20T08:24:06.000Z","updated":"2018-04-03T13:48:14.000Z","comments":true,"path":"2018/03/20/json-encode-of-php/","link":"","permalink":"https://musezhang.github.io/2018/03/20/json-encode-of-php/","excerpt":"前言 最近在使用json_encode函数的时候，发现自己以前使用json_encode太简单了。很多细节没有注意到，虽然也能用，但是却引发了一些问题。所以本文主要去记录下json_encode和json_decode的项目用法。","text":"前言 最近在使用json_encode函数的时候，发现自己以前使用json_encode太简单了。很多细节没有注意到，虽然也能用，但是却引发了一些问题。所以本文主要去记录下json_encode和json_decode的项目用法。 json_encode函数说明1string json_encode ( mixed $value [, int $options = 0 [, int $depth = 512 ]] ) 返回包含所提供值的JSON表示的字符串 详细参数说明value: 可以是任何非resource类型的任何数据类型的值options: 对value进行encode的选项,主要是控制特殊字符是否进行unicode编码，可以设置选项如下： JSON_HEX_TAG =&gt; 1 : 所有的 &lt; 和 &gt; 符号都被转换成\\u003C和\\u003E(since 5.3.0) 123$value = \"hello &lt;jcak&gt;\";echo json_encode($value) . \"\\n\"; //输出\"hello &lt;jack&gt;\"echo json_encode($value, JSON_HEX_TAG) . \"\\n\"; //输出\"hello \\u003Cjack\\u003E\" JSON_HEX_AMP =&gt; 2 : 所有的 &amp; 转换为\\u0026(since 5.3.0) 123$value = \"hello jack &amp;\";echo json_encode($value) . \"\\n\"; //输出\"hello jack &amp;\"echo json_encode($value, JSON_HEX_AMP) . \"\\n\"; //输出\"hello jack \\u0026\" JSON_HEX_APOS =&gt; 4：所有的单引号 ‘ 转换成\\u0027(since 5.3.0) 123$value = \"hello 'jack'\";echo json_encode($value) . \"\\n\"; //输出\"hello 'jack'\"echo json_encode($value, JSON_HEX_AMP) . \"\\n\"; \"hello \\u0027jack\\u0027\" JSON_HEX_QUOT =&gt; 8 : 所有的双引号 “ 转换成\\u0022（since 5.3.0) 123$value = 'hello \"jack\"';echo json_encode($value) . \"\\n\"; //输出\"hello \\\"jack\\\"\" ，为了区别外层的双引号，增加了转义字符，echo json_encode($value, JSON_HEX_QUOT) . \"\\n\"; //输出\"hello \\u0022jack\\u0022\" JSON_FORCE_OBJECT =&gt; 16 : 当使用非关联数组时，输出一个对象而不是数组。当输出的接收者期待对象并且数组为空时特别有用。(since 5.3.0) 1234567$value = array(\"a\", \"b\", \"c\");echo json_encode($value) . \"\\n\"; //输出[\"a\",\"b\",\"c\"]echo json_encode($value, JSON_FORCE_OBJECT) . \"\\n\"; //输出&#123;\"0\":\"a\",\"1\":\"b\",\"2\":\"c\"&#125;$value = array();echo json_encode($value) . \"\\n\"; //输出[]echo json_encode($value, JSON_FORCE_OBJECT) . \"\\n\"; //输出&#123;&#125; JSON_NUMERIC_CHECK =&gt; 32 : 将数字字符串编码为数字(since 5.3.3) 123$value = \"123456\";var_dump(json_encode($value)); //输出string(8) \"\"123456\"\",可以看出，转换出来的是字符串var_dump(json_encode($value, JSON_NUMERIC_CHECK));//输出string(6) \"123456\",可以看出转换出来的是数字，比不加参数，少两个字符 JSON_UNESCAPED_SLASHES =&gt; 64 : 不对反斜杠 /进行转义(since 5.4.0) 123$value = \"/hello jack\";echo json_encode($value) . \"\\n\"; //输出 \"\\/hello jack\"，做了转义处理echo json_encode($value, JSON_UNESCAPED_SLASHES)) . \"\\n\";// 输出string(13) \"/hello jack\"，未作转义处理 JSON_PRETTY_PRINT =&gt; 128 : 格式化返回的数据,美化输出，一般数组很有效(since 5.4.0) 1234567$value = array(\"word\" =&gt; \"hello jack\");echo json_encode($value) . \"\\n\"; //输出&#123;\"word\":\"hello jack\"&#125;echo json_encode($value, JSON_PRETTY_PRINT) . \"\\n\";//输出如下：&#123; \"word\": \"hello jack\"&#125; JSON_UNESCAPED_UNICODE =&gt; 256 :从字面上对多字节Unicode字符进行编码，如对中文不进行unicode转码，不会转换为\\uXXXX这种格式(since 5.4.0) 123$value = \"hello jack, 这是一条测试信息\";echo json_encode($value) . \"\\n\"; //输出\"hello jack, \\u8fd9\\u662f\\u4e00\\u6761\\u6d4b\\u8bd5\\u4fe1\\u606f\"echo json_encode($value, JSON_UNESCAPED_UNICODE) . \"\\n\"; //输出\"hello jack, 这是一条测试信息\" JSON_PARTIAL_OUTPUT_ON_ERROR =&gt; 512 :用一些不可修改的值代替失败(since 5.5.0) JSON_PRESERVE_ZERO_FRACTION =&gt; 1024 : 确保浮点值始终编码为浮点值(since 5.6.6)123$value = 277.00000;echo json_encode($value) . \"\\n\"; //输出：277，整数echo json_encode($value, JSON_PRESERVE_ZERO_FRACTION) . \"\\n\"; //输出277.0 浮点数 depth: 设置最大深度，必须大于0，主要是针对数组来说的，是可以encode的数组的最大深度12345$value = array(\"name\" =&gt; \"midui\", \"location\" =&gt; array(\"province\"=&gt;\"beijing\", \"city\"=&gt; \"beijing\"));echo json_encode($value) . \"\\n\"; //输出&#123;\"name\":\"midui\",\"location\":&#123;\"province\":\"beijing\",\"city\":\"beijing\"&#125;&#125;echo json_encode($value, JSON_PRESERVE_ZERO_FRACTION, 1) . \"\\n\"; //无法encode,注意，此时把第二个参数修改为JSON_PARTIAL_OUTPUT_ON_ERROR,则可以encode，原因不明 总结一般来说，我们使用json_encode都没有使用后两个参数，但是在某些特定的情况下，有一些参数还是可以供我们使用的。如： 需要对特殊符号(&lt;,&gt;,’,”,&amp;)进行编码的,使用JSON_HEX_TAG,JSON_HEX_AMP,JSON_HEX_APOS,JSON_HEX_QUOT等 不需要对中文进行编码的情况，使用JSON_UNESCAPED_UNICODE 需要将空数组编码为对象，而不是数组的时候使用JSON_FORCE_OBJECT 如果要使用多个参数，则可以将参数值相加，如同时需要对&lt;和&amp;进行编码,但不对中文编码，那么 第二个参数值 = JSON_HEX_TAG + JSON_HEX_AMP + JSON_UNESCAPED_UNICODE = 259 12345$value = \"hello &lt;jack&gt; &amp;, 你是谁\";echo json_encode($value) . \"\\n\"; //不特殊处理，输出\"hello &lt;jack&gt; &amp;, \\u4f60\\u662f\\u8c01\"echo json_encode($value, 1) . \"\\n\"; //对&lt;,&gt;编码，输出\"hello \\u003Cjack\\u003E &amp;, \\u4f60\\u662f\\u8c01\"echo json_encode($value, 3) . \"\\n\"; //对&lt;,&gt;,&amp;编码,输出\"hello \\u003Cjack\\u003E \\u0026, \\u4f60\\u662f\\u8c01\"echo json_encode($value, 259) . \"\\n\";//对&lt;,&gt;,&amp;编码,不对中文编码，输出\"hello \\u003Cjack\\u003E \\u0026, 你是谁\" json_decode函数说明1mixed json_decode ( string $json [, bool $assoc = FALSE [, int $depth = 512 [, int $options = 0 ]]] ) 将一个json字符串转换成php中的数组 详细参数说明json: 待转换的json串assoc: TRUE: json串转换为数据;FALSE: 转换为对象depth: 用户指定的可以处理的递归深度options: 对json进行decode的选项 JSON_BIGINT_AS_STRING: 将大整数转换为字符串而不是浮动，这是默认值 1234567891011121314$json = '&#123;\"number\": 12345678901234567890&#125;';$data = json_decode($json);var_dump($data);//输出//object(stdClass)#1 (1) &#123;// [\"number\"]=&gt;// float(1.2345678901235E+19)//&#125;$data2 = json_decode($json, false, 512, JSON_BIGINT_AS_STRING);var_dump($data2);//object(stdClass)#2 (1) &#123;// [\"number\"]=&gt;// string(20) \"12345678901234567890\"//&#125; JSON_OBJECT_AS_ARRAY: 效果不明。。。。详见官网说明 总结改方法的使用方法主要是要记住第二个参数。否则转换成的是对象而不是数据。 json_last_error函数说明12int json_last_error ( void )返回最近一次json_ddecode/json_encode发生的错误 返回结果说明 JSON_ERROR_NONE =&gt; 0: 未发生错误 JSON_ERROR_DEPTH =&gt; 1: 超出最大深度 JSON_ERROR_STATE_MISMATCH =&gt; 2: json格式不正确 JSON_ERROR_CTRL_CHAR =&gt; 3: 控制字符错误 JSON_ERROR_SYNTAX =&gt; 4: 语法错误 JSON_ERROR_UTF8 =&gt; 5: 格式错误的UTF-8字符 JSON_ERROR_RECURSION =&gt; 6: 要编码的值中的一个或多个递归引用 (since 5.5.0) JSON_ERROR_INF_OR_NAN =&gt; 7: 要编码的值中有一个或多个NAN或INF值 (since 5.5.0) JSON_ERROR_UNSUPPORTED_TYPE =&gt; 8: 给出了一个无法编码的类型的值 (since 5.5.0) JSON_ERROR_INVALID_PROPERTY_NAME =&gt; 9: 给出了一个无法编码的属性名称 (since 7.0.0) JSON_ERROR_UTF16 =&gt; 10: 格式错误的UTF-16字符 (since 7.0.0)","categories":[{"name":"php","slug":"php","permalink":"https://musezhang.github.io/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://musezhang.github.io/tags/php/"},{"name":"json_encode","slug":"json-encode","permalink":"https://musezhang.github.io/tags/json-encode/"},{"name":"json_decode","slug":"json-decode","permalink":"https://musezhang.github.io/tags/json-decode/"}]},{"title":"使用hexo-blog-encrypt-完成博文加密","slug":"hexo-encrypt","date":"2018-03-18T15:18:45.000Z","updated":"2018-03-18T16:17:17.000Z","comments":true,"path":"2018/03/18/hexo-encrypt/","link":"","permalink":"https://musezhang.github.io/2018/03/18/hexo-encrypt/","excerpt":"Description of how to user hexo-encrypt.","text":"The password is 123456 Decrypt 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","categories":[{"name":"hexo","slug":"hexo","permalink":"https://musezhang.github.io/categories/hexo/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://musezhang.github.io/tags/工具/"},{"name":"hexo","slug":"hexo","permalink":"https://musezhang.github.io/tags/hexo/"}]},{"title":"一些需要禁用的PHP危险函数","slug":"some-dangerous-functions-in-php","date":"2018-03-05T17:01:56.000Z","updated":"2018-03-20T17:29:48.000Z","comments":true,"path":"2018/03/06/some-dangerous-functions-in-php/","link":"","permalink":"https://musezhang.github.io/2018/03/06/some-dangerous-functions-in-php/","excerpt":"说明 本文说明了一些在php中需要禁用的函数，这些函数可能会引起服务器问题，造成不必要的麻烦。","text":"说明 本文说明了一些在php中需要禁用的函数，这些函数可能会引起服务器问题，造成不必要的麻烦。 有哪些？ phpinfo()功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。危险等级：中 passthru()功能描述：允许执行一个外部程序并回显输出，类似于 exec()。危险等级：高 exec()功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。危险等级：高 system()功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。危险等级：高 chroot()功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式,PHP 时才能工作，且该函数不适用于 Windows 系统。危险等级：高 scandir()功能描述：列出指定路径中的文件和目录。危险等级：中 chgrp()功能描述：改变文件或目录所属的用户组。危险等级：高 chown()功能描述：改变文件或目录的所有者。危险等级：高 shell_exec()功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。危险等级：高 proc_open()功能描述：执行一个命令并打开文件指针用于读取以及写入。危险等级：高 proc_get_status()功能描述：获取使用 proc_open() 所打开进程的信息。危险等级：高 error_log()功能描述：将错误信息发送到指定位置（文件）。安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，执行任意命令。危险等级：低 ini_alter()功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。具体参见 ini_set()。危险等级：高 ini_set()功能描述：可用于修改、设置 PHP 环境配置参数。危险等级：高 ini_restore()功能描述：可用于恢复 PHP 环境配置参数到其初始值。危险等级：高 dl()功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。危险等级：高 pfsockopen()功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。危险等级：高 syslog()功能描述：可调用 UNIX 系统的系统层 syslog() 函数。危险等级：中 readlink()功能描述：返回符号连接指向的目标文件内容。危险等级：中 symlink()功能描述：在 UNIX 系统中建立一个符号链接。危险等级：高 popen()功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。危险等级: 高 stream_socket_server()功能描述：建立一个 Internet 或 UNIX 服务器连接。危险等级：中 putenv()功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。危险等级：高 禁用方法 打开/etc/php.ini文件， 查找到 disable_functions ，添加需禁用的函数名，如下：1phpinfo,eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen","categories":[{"name":"php","slug":"php","permalink":"https://musezhang.github.io/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://musezhang.github.io/tags/php/"},{"name":"code","slug":"code","permalink":"https://musezhang.github.io/tags/code/"}]},{"title":"【译文】mysql8.0:退出对查询缓存的支持","slug":"mysql-8-0-retiring-support-for-the-query-cache","date":"2017-10-19T18:37:37.000Z","updated":"2018-03-18T15:58:18.000Z","comments":true,"path":"2017/10/20/mysql-8-0-retiring-support-for-the-query-cache/","link":"","permalink":"https://musezhang.github.io/2017/10/20/mysql-8-0-retiring-support-for-the-query-cache/","excerpt":"原文链接：http://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/ Author:Morgan Tocker(the Product Manager for the MySQL Server) 前言正如Rene昨天在ProxySQL博客上写道： 尽管MySQL查询缓存旨在提高性能，但它具有严重的可扩展性问题，并且很容易成为严重的瓶颈。 这确实是我们在MySQL团队观察一段时间后得到的结论。在我们了解今天的文章之前，让我先来介绍一下查询缓存。","text":"原文链接：http://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/ Author:Morgan Tocker(the Product Manager for the MySQL Server) 前言正如Rene昨天在ProxySQL博客上写道： 尽管MySQL查询缓存旨在提高性能，但它具有严重的可扩展性问题，并且很容易成为严重的瓶颈。 这确实是我们在MySQL团队观察一段时间后得到的结论。在我们了解今天的文章之前，让我先来介绍一下查询缓存。 查询缓存简介MySQL查询缓存是查询结果缓存。他会将以SEL开头的查询语句与一个散列表进行比较，如果有匹配则返回上一次执行查询的结果。这里还有一些限制： 查询必须匹配字节级的匹配（查询缓存避免解析） 使用非确定性特征将导致查询不被缓存（包括临时表，用户变量，RAND（），NOW（）和UDF）） 查询缓存旨在不提供过时的结果。对基础表的任何修改都会导致所有缓存对于这些表无效。 如果缓存用在InnoDB引擎中，会有一些限制（对于MVCC，因为您打开了一个事务，“缓存”可能不会得到用户预期中的数据） 最佳案例正如我几年前在个人博客上写的： 查询缓存的理想使用场景往往在很大程度上是只读的，这个场景下，通过非常大的代价去检查数百万行数据，但是指返回很少的结果 一个假设出的例子是可能有一个复杂的查询来得到一个网页上的表单中的下拉列表的值，在这种情况下，查询缓存可以掩盖由于缺少的索引引起的查询性能问题，这对新手用户有帮助。 这个观点在今天仍然适用，但是我认为重要的是还要指出，我们现在已经有很多DBA工具的对这些性能有所改善： 在MySQL服务器中，我们现在可以重写查询以插入提示（或通过其他修改来提高性能） 我们有如ProxySQL这样的第三方工具，可以充当中间人查询缓存。 ProxySQL还支持缓存的TTL，它在我之前提供的示例中可以正常工作（构建下拉列表的值列表）。 查询缓存的限制自从MySQL 5.6（2013）以来，查询缓存已被禁用，因为它已知在多核机器上不能与高吞吐量工作负载的规模相比较。 Rene昨天在他的帖子中证实了这一点，而且这个问题之前也曾被Stewart Smith和Domas Mituzas（更新：Kristian Koehntopp）提及。 假设可扩展性可以提高，查询缓存的限制因素在于，只有查询命中了的缓存才能看到改进; 它不太可能提高性能的可预测性。 对于面向用户的系统，降低性能的可变性通常比提高峰值吞吐量更重要：数据来源 决定删除对查询缓存的支持我们赞同University of Michigan, Ann Arbor大学的Jiamin Huang，Barzan Mozafari，Grant Schoenebeck，Thomas F. Wenisch的研究成果。 我们考虑了两种方案：一个是我们可以对查询缓存进行哪些改进的方案，另一个是我们可以做出哪些改进，从而为所有工作负载提供改进。 虽然这些选择本身是正交的，但工程资源是有限的。也就是说，我们要改变战略，去把资源投资到能够普遍适用于所有工作负载的改进上来。 我们也同意Rene的结论，即缓存在靠近客户端时提供了最大的好处将缓存移到客户端时，“Client + 2x ProxySQL”结果显示性能提升了5.2倍。 现有用户的升级路径根据当前的提示说明，查询缓存在MySQL 5.7一下版本仍然会继续得到支持。 但MySQL 8.0不再支持查询缓存，用户升级将被鼓励使用服务器端查询重写或ProxySQL作为中间缓存 我们预计这种变化只会影响到少数用户，但如果您关心此问题，请联系并联系！ 感谢您使用MySQL！！","categories":[{"name":"mysql","slug":"mysql","permalink":"https://musezhang.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://musezhang.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://musezhang.github.io/tags/数据库/"},{"name":"查询缓存","slug":"查询缓存","permalink":"https://musezhang.github.io/tags/查询缓存/"}]},{"title":"数据库查询缓存","slug":"mysql-query-cache","date":"2017-10-19T17:31:34.000Z","updated":"2017-10-19T18:41:27.000Z","comments":true,"path":"2017/10/20/mysql-query-cache/","link":"","permalink":"https://musezhang.github.io/2017/10/20/mysql-query-cache/","excerpt":"起因起因是近期，集客中的数据又出现了查询极慢的情况。单表1100W数据,在进行count(*)查询的时候,查询性能极差，按照特定条件的查询(已加索引)，查询出月500W数据的时候，大约耗时18s多。可能解决方案: 存储引擎修改 查询语句优化 离线预查(此方案结合业务场景)详见此文：[mysql千万级数据count性能优化] 在解决的过程中顺道看了下查询缓存的问题，线上库竟然没有开启查询缓存。特此做了些记录。","text":"起因起因是近期，集客中的数据又出现了查询极慢的情况。单表1100W数据,在进行count(*)查询的时候,查询性能极差，按照特定条件的查询(已加索引)，查询出月500W数据的时候，大约耗时18s多。可能解决方案: 存储引擎修改 查询语句优化 离线预查(此方案结合业务场景)详见此文：[mysql千万级数据count性能优化] 在解决的过程中顺道看了下查询缓存的问题，线上库竟然没有开启查询缓存。特此做了些记录。 查询缓存原理查询缓存的实现原理查询缓存的写入与过期查询缓存相关参数说明查询缓存参数1234567891011121314mysql&gt; show status like “%Qcache%”;+-------------------------+---------+| Variable_name | Value |+-------------------------+---------+| Qcache_free_blocks | 1639 || Qcache_free_memory | 5579448 || Qcache_hits | 1464051 || Qcache_inserts | 2442792 || Qcache_lowmem_prunes | 1910628 || Qcache_not_cached | 447381 || Qcache_queries_in_cache | 8707 || Qcache_total_blocks | 19402 |+-------------------------+---------+ 变量名称 中文 英文 备注 Qcache_free_blocks 查询缓存中空闲内存块数量 The number of free memory blocks in the query cache Qcache_free_memory 查询缓存中空闲内存大小 The amount of free memory for the query cache. 单位B Qcache_hits 查询缓存命中数 The number of query cache hits Qcache_inserts 加入查询缓存的语句数量 The number of queries added to the query cache. Qcache_lowmem_prunes 由于内存不足删除的查询语句数 The number of queries that were deleted from the query cache because of low memory 这个数字的持续增长说明内存不足或碎片严重 Qcache_not_cached 没有被缓存的查询语句数 The number of noncached queries Qcache_queries_in_cache 查询缓存中的语句数 The number of queries registered in the query cache Qcache_total_blocks 查询缓存的块数 The total number of blocks in the query cache 备注：所有上述参数都已经在mysql5.7.20弃用,在8.0删除,使用时，请确认mysql版本 查询缓存配置参数1234567891011mysql&gt; show variables like 'query_cache%';+------------------------------+----------+| Variable_name | Value |+------------------------------+----------+| query_cache_limit | 1048576 || query_cache_min_res_unit | 4096 || query_cache_size | 16777216 || query_cache_type | ON || query_cache_wlock_invalidate | OFF |+------------------------------+----------+5 rows in set (0.00 sec) 变量名称 中文 英文 备注 query_cache_limit 查询结果最大限制，大于这个值的不缓存 Do not cache results that are larger than this number of bytes. The default value is 1MB. 默认1MB query_cache_min_res_unit 查询缓存中分配的块的最小大小 The minimum size (in bytes) for blocks allocated by the query cache 字节为单位，默认4096B query_cache_size 用于缓存查询结果的缓存大小 The amount of memory allocated for caching query results. 默认1M query_cache_type 查询缓存的类型0/OFF：不进行查询缓存；1：缓存除SELECT SQL_NO_CACHE开头的所有可缓存查询结果；2：值缓存以SELECT SQL_CACHE开头的可缓存查询 Set the query cache type 默认OFF,如果选择OFF，并不会清空查询缓存大小，如果需要，需设置query_cache_size=0 query_cache_wlock_invalidate 针对MyISAM引擎表，对表的请求进行限制 Normally, when one client acquires a WRITE lock on a MyISAM table, other clients are not blocked from issuing statements that read from the table if the query results are present in the query cache. Setting this variable to 1 causes acquisition of a WRITE lock for a table to invalidate any queries in the query cache that refer to the table. This forces other clients that attempt to access the table to wait while the lock is in effect 具体解释参见官方说明 备注：所有上述参数都已经在mysql5.7.20弃用,在8.0删除,使用时，请确认mysql版本 参考文件 5.1.7 Server Status Variables 5.1.5 Server System Variables MySQL查询缓存变量 MYSQL会把查询的结果缓存多久?一个考验人的技术问题 [译文]mysql8.0:退出对查询缓存的支持","categories":[{"name":"mysql","slug":"mysql","permalink":"https://musezhang.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://musezhang.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://musezhang.github.io/tags/数据库/"},{"name":"查询缓存","slug":"查询缓存","permalink":"https://musezhang.github.io/tags/查询缓存/"}]},{"title":"单例模式","slug":"design-patterns-singleton","date":"2017-09-23T09:01:30.000Z","updated":"2018-03-18T15:58:48.000Z","comments":true,"path":"2017/09/23/design-patterns-singleton/","link":"","permalink":"https://musezhang.github.io/2017/09/23/design-patterns-singleton/","excerpt":"意图 保证一个类仅有一个实例，并提供访问它的全局访问点 我的理解：","text":"意图 保证一个类仅有一个实例，并提供访问它的全局访问点 我的理解： 适用性 当类只能有一个实例，而且客户可以从一个众所周知的访问点访问它 当这个唯一的实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时 我的理解： 结构 代码示例123456789101112131415161718192021222324252627282930testsingleton();class singleton&#123; private static $object = null; protected function __construct() &#123; print \"create object\\n\"; &#125; public static function getInstance() &#123; if(self::$object == null) &#123; self::$object = new singleton(); &#125; return self::$object; &#125;&#125;function testsingleton()&#123; $object = singleton::getInstance(); $object2 = singleton::getInstance(); echo $object == $object2 ? \"one object\" : 'tow object'; echo PHP_EOL;&#125; 明显特征 定义了一个public类型的用来返回对象的方法 定义了一个人private的私有属性，代表具体的类对象，只能通过public方法获得 非public的构造函数，不可直接new对象","categories":[{"name":"代码的艺术","slug":"代码的艺术","permalink":"https://musezhang.github.io/categories/代码的艺术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://musezhang.github.io/tags/设计模式/"},{"name":"design patterns","slug":"design-patterns","permalink":"https://musezhang.github.io/tags/design-patterns/"},{"name":"单例模式","slug":"单例模式","permalink":"https://musezhang.github.io/tags/单例模式/"}]},{"title":"五个设计模式","slug":"five-design-patterns","date":"2017-08-26T03:22:43.000Z","updated":"2017-09-23T09:00:56.000Z","comments":true,"path":"2017/08/26/five-design-patterns/","link":"","permalink":"https://musezhang.github.io/2017/08/26/five-design-patterns/","excerpt":"说在前边 设计模式是我曾经拿起又放下的东西，经典的设计模式那本书也是看过的,但无奈却没有看完。当了两年多的程序员，回想一下，自己对设计模式的理解竟然还是如此的不堪。 随着年龄的增长，工作年限的增加，越发觉得知识的不足与停滞。所以是时候真的真的该慢慢的，默默的学习一些东西了，不然，焦躁的情绪就无处发泄。也许，静静的学习，成长，才能帮助我安静下来，沉淀知识，获得成长。","text":"说在前边 设计模式是我曾经拿起又放下的东西，经典的设计模式那本书也是看过的,但无奈却没有看完。当了两年多的程序员，回想一下，自己对设计模式的理解竟然还是如此的不堪。 随着年龄的增长，工作年限的增加，越发觉得知识的不足与停滞。所以是时候真的真的该慢慢的，默默的学习一些东西了，不然，焦躁的情绪就无处发泄。也许，静静的学习，成长，才能帮助我安静下来，沉淀知识，获得成长。 本次主要会重点记录自己重新学习五种主要设计模式的一些心得，做个记录。一来，帮助自己增强记忆学习；二来做个记录，方便后边回顾。 为什么选择这几个模式呢，只能说，就我所知，他们被说的更多，被用的更多。 目录创建型 工厂模式 单例模式 结构型 适配器模式 行为型 策略模式 观察者模式","categories":[{"name":"代码的艺术","slug":"代码的艺术","permalink":"https://musezhang.github.io/categories/代码的艺术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://musezhang.github.io/tags/设计模式/"},{"name":"design patterns","slug":"design-patterns","permalink":"https://musezhang.github.io/tags/design-patterns/"}]},{"title":"工厂模式","slug":"design-patterns-Factory","date":"2017-08-26T03:11:00.000Z","updated":"2017-08-26T03:33:32.000Z","comments":true,"path":"2017/08/26/design-patterns-Factory/","link":"","permalink":"https://musezhang.github.io/2017/08/26/design-patterns-Factory/","excerpt":"","text":"","categories":[{"name":"代码的艺术","slug":"代码的艺术","permalink":"https://musezhang.github.io/categories/代码的艺术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://musezhang.github.io/tags/设计模式/"},{"name":"design patterns","slug":"design-patterns","permalink":"https://musezhang.github.io/tags/design-patterns/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://musezhang.github.io/tags/工厂模式/"}]},{"title":"linux下忘记mysql的root密码怎么办","slug":"forget-mysql-password","date":"2017-08-17T06:00:04.000Z","updated":"2017-08-17T06:13:24.000Z","comments":true,"path":"2017/08/17/forget-mysql-password/","link":"","permalink":"https://musezhang.github.io/2017/08/17/forget-mysql-password/","excerpt":"修改MySql的登录设置vi /etc/my.cnf 在[mysqld]的段中加上一句：skip-grant-tablesExample:1234[mysqld]port = 3306socket = /tmp/mysql.sockskip-grant-tables 【备注】：此操作后数据库不需要密码即可登录，请确认网络环境安全后进行操作","text":"修改MySql的登录设置vi /etc/my.cnf 在[mysqld]的段中加上一句：skip-grant-tablesExample:1234[mysqld]port = 3306socket = /tmp/mysql.sockskip-grant-tables 【备注】：此操作后数据库不需要密码即可登录，请确认网络环境安全后进行操作 重启mysql此命令前提是linux已配置可使用此种方式重启mysql123# service mysql restartShutting down MySQL.. SUCCESS!Starting MySQL.. SUCCESS! 登录mysql并修改root密码登录mysql1mysql -uroot 修改root用户密码1234mysql&gt; use user;mysql&gt; update user set Password = password(\"new_password\") where User=\"root\";mysql&gt; quit;Bye 将my.cnf配置改回来重启mysql 接下来就可以使用新密码登录了","categories":[{"name":"mysql","slug":"mysql","permalink":"https://musezhang.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://musezhang.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://musezhang.github.io/tags/数据库/"},{"name":"Linux","slug":"Linux","permalink":"https://musezhang.github.io/tags/Linux/"}]},{"title":"保证分布式系统数据一致性的6种方案","slug":"6-method-ensure-consistency","date":"2017-08-09T16:24:39.000Z","updated":"2017-08-09T16:56:24.000Z","comments":true,"path":"2017/08/10/6-method-ensure-consistency/","link":"","permalink":"https://musezhang.github.io/2017/08/10/6-method-ensure-consistency/","excerpt":"来自：@高可用架构​​​​原文链接：http://weibo.com/ttarticle/p/show?id=2309403965965003062676#_0 编者按：本文由「高可用架构后花园」群讨论整理而成。有人的地方，就有江湖有江湖的地方，就有纷争","text":"来自：@高可用架构​​​​原文链接：http://weibo.com/ttarticle/p/show?id=2309403965965003062676#_0 编者按：本文由「高可用架构后花园」群讨论整理而成。有人的地方，就有江湖有江湖的地方，就有纷争 问题的起源在电商等业务中，系统一般由多个独立的服务组成，如何解决分布式调用时候数据的一致性？ 具体业务场景如下，比如一个业务操作，如果同时调用服务 A、B、C，需要满足要么同时成功；要么同时失败。A、B、C 可能是多个不同部门开发、部署在不同服务器上的远程服务。 在分布式系统来说，如果不想牺牲一致性，CAP 理论告诉我们只能放弃可用性，这显然不能接受。为了便于讨论问题，先简单介绍下数据一致性的基础理论。 强一致 当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。 弱一致性 系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到 最终一致性 弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。 在工程实践上，为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。但在电商等场景中，对于数据一致性的解决方法和常见的互联网系统（如 MySQL 主从同步）又有一定区别，群友的讨论分成以下 6 种解决方案。 规避分布式事务——业务整合业务整合方案主要采用将接口整合到本地执行的方法。拿问题场景来说，则可以将服务 A、B、C 整合为一个服务 D 给业务，这个服务 D 再通过转换为本地事务的方式，比如服务 D 包含本地服务和服务 E，而服务 E 是本地服务 A ~ C 的整合。 优点：解决（规避）了分布式事务。 缺点：显而易见，把本来规划拆分好的业务，又耦合到了一起，业务职责不清晰，不利于维护。 由于这个方法存在明显缺点，通常不建议使用。 经典方案 - eBay 模式此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。 消息日志方案的核心是保证服务接口的幂等性。 考虑到网络通讯失败、数据丢包等原因，如果接口不能保证幂等性，数据的唯一性将很难保证。 eBay 方式的主要思路如下。 Base：一种 Acid 的替代方案 此方案是 eBay 的架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章，是一篇解释 BASE 原则，或者说最终一致性的经典文章。文中讨论了 BASE 与 ACID 原则在保证数据一致性的基本差异。 如果 ACID 为分区的数据库提供一致性的选择，那么如何实现可用性呢？答案是 BASE (basically available, soft state, eventually consistent) BASE 的可用性是通过支持局部故障而不是系统全局故障来实现的。下面是一个简单的例子：如果将用户分区在 5 个数据库服务器上，BASE 设计鼓励类似的处理方式，一个用户数据库的故障只影响这台特定主机那 20% 的用户。这里不涉及任何魔法，不过它确实可以带来更高的可感知的系统可用性。 文章中描述了一个最常见的场景，如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。这两个表属于不同的远程服务，所以就涉及到分布式事务一致性的问题。 文中提出了一个经典的解决方法，将主要修改操作以及更新用户表的消息放在一个本地事务来完成。同时为了避免重复消费用户表消息带来的问题，达到多次重试的幂等性，增加一个更新记录表 updates_applied 来记录已经处理过的消息。 系统的执行伪代码如下 去哪儿网分布式事务方案随着业务规模不断地扩大，电商网站一般都要面临拆分之路。就是将原来一个单体应用拆分成多个不同职责的子系统。比如以前可能将面向用户、客户和运营的功能都放在一个系统里，现在拆分为订单中心、代理商管理、运营系统、报价中心、库存管理等多个子系统。 拆分首先要面临的是什么呢？ 最开始的单体应用所有功能都在一起，存储也在一起。比如运营要取消某个订单，那直接去更新订单表状态，然后更新库存表就 ok 了。因为是单体应用，库在一起，这些都可以在一个事务里，由关系数据库来保证一致性。 但拆分之后就不同了，不同的子系统都有自己的存储。比如订单中心就只管理自己的订单库，而库存管理也有自己的库。那么运营系统取消订单的时候就是通过接口调用等方式来调用订单中心和库存管理的服务了，而不是直接去操作库。这就涉及一个『分布式事务』的问题。 分布式事务有两种解决方式 优先使用异步消息。上文已经说过，使用异步消息 Consumer 端需要实现幂等。 幂等有两种方式，一种方式是业务逻辑保证幂等。比如接到支付成功的消息订单状态变成支付完成，如果当前状态是支付完成，则再收到一个支付成功的消息则说明消息重复了，直接作为消息成功处理。 另外一种方式如果业务逻辑无法保证幂等，则要增加一个去重表或者类似的实现。对于 producer 端在业务数据库的同实例上放一个消息库，发消息和业务操作在同一个本地事务里。发消息的时候消息并不立即发出，而是向消息库插入一条消息记录，然后在事务提交的时候再异步将消息发出，发送消息如果成功则将消息库里的消息删除，如果遇到消息队列服务异常或网络问题，消息没有成功发出那么消息就留在这里了，会有另外一个服务不断地将这些消息扫出重新发送。 有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果。这种情况的实现方式其实和上面类似，每个参与方的本地业务库的同实例上面放一个事务记录库。 比如 A 同步调用 B，C。A 本地事务成功的时候更新本地事务记录状态，B 和 C 同样。如果有一次 A 调用 B 失败了，这个失败可能是 B 真的失败了，也可能是调用超时，实际 B 成功。则由一个中心服务对比三方的事务记录表，做一个最终决定。假设现在三方的事务记录是 A 成功，B 失败，C 成功。那么最终决定有两种方式，根据具体场景： 重试 B，直到 B 成功，事务记录表里记录了各项调用参数等信息； 执行 A 和 B 的补偿操作(一种可行的补偿方式是回滚)。 对 b 场景做一个特殊说明：比如 B 是扣库存服务，在第一次调用的时候因为某种原因失败了，但是重试的时候库存已经变为 0，无法重试成功，这个时候只有回滚 A 和 C 了。 那么可能有人觉得在业务库的同实例里放消息库或事务记录库，会对业务侵入，业务还要关心这个库，是否一个合理的设计？ 实际上可以依靠运维的手段来简化开发的侵入，我们的方法是让 DBA 在公司所有 MySQL 实例上预初始化这个库，通过框架层（消息的客户端或事务 RPC 框架）透明的在背后操作这个库，业务开发人员只需要关心自己的业务逻辑，不需要直接访问这个库。 总结起来，其实两种方式的根本原理是类似的，也就是将分布式事务转换为多个本地事务，然后依靠重试等方式达到最终一致性。 蘑菇街交易创建过程中的分布式一致性方案交易创建的一般性流程 我们把交易创建流程抽象出一系列可扩展的功能点，每个功能点都可以有多个实现（具体的实现之间有组合/互斥关系）。把各个功能点按照一定流程串起来，就完成了交易创建的过程。 面临的问题 每个功能点的实现都可能会依赖外部服务。那么如何保证各个服务之间的数据是一致的呢？比如锁定优惠券服务调用超时了，不能确定到底有没有锁券成功，该如何处理？再比如锁券成功了，但是扣减库存失败了，该如何处理？ 方案选型 服务依赖过多，会带来管理复杂性增加和稳定性风险增大的问题。试想如果我们强依赖 10 个服务，9 个都执行成功了，最后一个执行失败了，那么是不是前面 9 个都要回滚掉？这个成本还是非常高的。 所以在拆分大的流程为多个小的本地事务的前提下，对于非实时、非强一致性的关联业务写入，在本地事务执行成功后，我们选择发消息通知、关联事务异步化执行的方案。 消息通知往往不能保证 100% 成功；且消息通知后，接收方业务是否能执行成功还是未知数。前者问题可以通过重试解决；后者可以选用事务消息来保证。 但是事务消息框架本身会给业务代码带来侵入性和复杂性，所以我们选择基于 DB 事件变化通知到 MQ 的方式做系统间解耦，通过订阅方消费 MQ 消息时的 ACK 机制，保证消息一定消费成功，达到最终一致性。由于消息可能会被重发，消息订阅方业务逻辑处理要做好幂等保证。 所以目前只剩下需要实时同步做、有强一致性要求的业务场景了。在交易创建过程中，锁券和扣减库存是这样的两个典型场景。 要保证多个系统间数据一致，乍一看，必须要引入分布式事务框架才能解决。但引入非常重的类似二阶段提交分布式事务框架会带来复杂性的急剧上升；在电商领域，绝对的强一致是过于理想化的，我们可以选择准实时的最终一致性。 我们在交易创建流程中，首先创建一个不可见订单，然后在同步调用锁券和扣减库存时，针对调用异常（失败或者超时），发出废单消息到MQ。如果消息发送失败，本地会做时间阶梯式的异步重试；优惠券系统和库存系统收到消息后，会进行判断是否需要做业务回滚，这样就准实时地保证了多个本地事务的最终一致性。 支付宝及蚂蚁金融云的分布式服务 DTS 方案业界常用的还有支付宝的一种 xts 方案，由支付宝在 2PC 的基础上改进而来。主要思路如下，大部分信息引用自官方网站。 分布式事务服务简介分布式事务服务 (Distributed Transaction Service, DTS) 是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。DTS 从架构上分为 xts-client 和 xts-server 两部分，前者是一个嵌入客户端应用的 JAR 包，主要负责事务数据的写入和处理；后者是一个独立的系统，主要负责异常事务的恢复。 核心特性传统关系型数据库的事务模型必须遵守 ACID 原则。在单数据库模式下，ACID 模型能有效保障数据的完整性，但是在大规模分布式环境下，一个业务往往会跨越多个数据库，如何保证这多个数据库之间的数据一致性，需要其他行之有效的策略。在 JavaEE 规范中使用 2PC (2 Phase Commit, 两阶段提交) 来处理跨 DB 环境下的事务问题，但是 2PC 是反可伸缩模式，也就是说，在事务处理过程中，参与者需要一直持有资源直到整个分布式事务结束。这样，当业务规模达到千万级以上时，2PC 的局限性就越来越明显，系统可伸缩性会变得很差。基于此，我们采用 BASE 的思想实现了一套类似 2PC 的分布式事务方案，这就是 DTS。DTS在充分保障分布式环境下高可用性、高可靠性的同时兼顾数据一致性的要求，其最大的特点是保证数据最终一致 (Eventually consistent)。 简单的说，DTS 框架有如下特性： 最终一致：事务处理过程中，会有短暂不一致的情况，但通过恢复系统，可以让事务的数据达到最终一致的目标。 协议简单：DTS 定义了类似 2PC 的标准两阶段接口，业务系统只需要实现对应的接口就可以使用 DTS 的事务功能。 与 RPC 服务协议无关：在 SOA 架构下，一个或多个 DB 操作往往被包装成一个一个的 Service，Service 与 Service 之间通过 RPC 协议通信。DTS 框架构建在 SOA 架构上，与底层协议无关。 与底层事务实现无关： DTS 是一个抽象的基于 Service 层的概念，与底层事务实现无关，也就是说在 DTS 的范围内，无论是关系型数据库 MySQL，Oracle，还是 KV 存储 MemCache，或者列存数据库 HBase，只要将对其的操作包装成 DTS 的参与者，就可以接入到 DTS 事务范围内。 以下是分布式事务框架的流程图 实现 一个完整的业务活动由一个主业务服务与若干从业务服务组成。 主业务服务负责发起并完成整个业务活动。 从业务服务提供 TCC 型业务操作。 业务活动管理器控制业务活动的一致性，它登记业务活动中的操作，并在活动提交时确认所有的两阶段事务的 confirm 操作，在业务活动取消时调用所有两阶段事务的 cancel 操作。” 与 2PC 协议比较 没有单独的 Prepare 阶段，降低协议成本 系统故障容忍度高，恢复简单 农信网数据一致性方案电商业务公司的支付部门，通过接入其它第三方支付系统来提供支付服务给业务部门，支付服务是一个基于 Dubbo 的 RPC 服务。对于业务部门来说，电商部门的订单支付，需要调用 支付平台的支付接口来处理订单； 同时需要调用积分中心的接口，按照业务规则，给用户增加积分。 从业务规则上需要同时保证业务数据的实时性和一致性，也就是支付成功必须加积分。 我们采用的方式是同步调用，首先处理本地事务业务。考虑到积分业务比较单一且业务影响低于支付，由积分平台提供增加与回撤接口。 具体的流程是先调用积分平台增加用户积分，再调用支付平台进行支付处理，如果处理失败，catch 方法调用积分平台的回撤方法，将本次处理的积分订单回撤。 用户信息变更公司的用户信息，统一由用户中心维护，而用户信息的变更需要同步给各业务子系统，业务子系统再根据变更内容，处理各自业务。用户中心作为 MQ 的 producer，添加通知给 MQ。APP Server 订阅该消息，同步本地数据信息，再处理相关业务比如 APP 退出下线等。 我们采用异步消息通知机制，目前主要使用 ActiveMQ，基于 Virtual Topic 的订阅方式，保证单个业务集群订阅的单次消费。 总结分布式服务对衍生的配套系统要求比较多，特别是我们基于消息、日志的最终一致性方案，需要考虑消息的积压、消费情况、监控、报警等。 参考资料 Base: An Acid Alternative (eBay 方案) In partitioned databases, trading some consistency for availability can lead to dramatic improvements in scalability. 英文版 ： http://queue.acm.org/detail.cfm?id=1394128 中文版： http://article.yeeyan.org/view/167444/125572 分布式事务服务 (DTS) https://www.cloud.alipay.com/docs/middleware/xts/index.html 感谢李玉福、余昭辉、蘑菇街七公提供方案，其他多位群成员对本文内容亦有贡献。 本文编辑李玉福、Tim Yang，转载请注明来自​​​​","categories":[{"name":"架构","slug":"架构","permalink":"https://musezhang.github.io/categories/架构/"}],"tags":[{"name":"分布式系统","slug":"分布式系统","permalink":"https://musezhang.github.io/tags/分布式系统/"},{"name":"一致性","slug":"一致性","permalink":"https://musezhang.github.io/tags/一致性/"}]},{"title":"mysql查询数据库和表所占空间大小","slug":"mysql-space-used","date":"2017-08-08T15:50:00.000Z","updated":"2017-08-10T09:48:54.000Z","comments":true,"path":"2017/08/08/mysql-space-used/","link":"","permalink":"https://musezhang.github.io/2017/08/08/mysql-space-used/","excerpt":"查询数据库所占空间大小1SELECT sum(DATA_LENGTH)+sum(INDEX_LENGTH) FROM information_schema.TABLES WHERE D 得到的结果是单位是字节Byte 查询数据库中所有表所占空间的大小","text":"查询数据库所占空间大小1SELECT sum(DATA_LENGTH)+sum(INDEX_LENGTH) FROM information_schema.TABLES WHERE D 得到的结果是单位是字节Byte 查询数据库中所有表所占空间的大小 在数据库的中的information_schema数据库中有一个 TABLES 表，这个表主要字段分别是： 字段名 含义 TABLE_SCHEMA 数据库名 TABLE_NAME 表名 ENGINE 所使用的存储引擎 TABLES_ROWS 记录数 DATA_LENGTH 数据大小 INDEX_LENGTH 索引大小 查询所有表数据和索引的的大小 1SELECT TABLE_NAME,DATA_LENGTH+INDEX_LENGTH,TABLE_ROWS FROM information_schema.TABLES WHERE TABLE_SCHEMA=\"数据库名\"; 查询某个表的数据大小和索引大小 1SELECT TABLE_NAME,DATA_LENGTH+INDEX_LENGTH,TABLE_ROWS FROM information_schema.TABLES WHERE TABLE_SCHEMA=\"数据库名\" AND TABLE_NAME=\"表名\";","categories":[{"name":"mysql","slug":"mysql","permalink":"https://musezhang.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://musezhang.github.io/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://musezhang.github.io/tags/数据库/"}]},{"title":"必须好使的git命令","slug":"useful-git-command","date":"2017-07-29T09:04:58.000Z","updated":"2017-07-30T07:48:37.000Z","comments":true,"path":"2017/07/29/useful-git-command/","link":"","permalink":"https://musezhang.github.io/2017/07/29/useful-git-command/","excerpt":"git设置颜色高亮显示1git config --global color.ui true git 命令别名设置1git config --global alias.br branch","text":"git设置颜色高亮显示1git config --global color.ui true git 命令别名设置1git config --global alias.br branch 查看git提交日志1git log 查看最近的提交内容123git show #最近一次git show HEAD^ #往前推一次,等于git show HEAD~1 git show HEAD^^ #往前推两次,等于git show HEAD~2 找到规律的同学应该知道怎么看更早之前的记录了 一次加入所有修改，包括delete12git add -u #一次加入所有被修改的内容，包含 modified 及 deletedgit add --update #同上 移动文件或重命名12git mv my_folder/numbers.txt . #将my_folder/numbers.txt文件移动到当前目录,文件名不变git mv numbers.txt num.txt #修改文件名 Git将”尚未被提交”的内容分成三种类型，分別是 Changes to be committed（将要提交的内容） Changes not staged for commit（被修改但未提交） Untracked files（没有如版本库的文件） 撤销修改 变回未修改状态 1git checkout -- &lt;file&gt; 回到未提交状态 1git reset HEAD &lt;file&gt; 回到指定版本12345git log --oneline #显示log日志，但只显示commit id和提交描述a2ba80 First commit80635e7 增加index.html文件c65ef5e Create README.md 选择commit id 使用下述命令回到指定版本 1git reset --hard 5a2ba80 查看git历史修改记录1234git reflog #查看所有记录80635e7 HEAD@&#123;2&#125;: commit: 增加index.html文件 #三列;1是commit id;2是short name;3是描述git show &lt;commit id&gt; #查看指定记录git show &lt;short name&gt; #同上 分支管理创建并删除分支1234git branch developgit checkout -b &lt;new branch name&gt; #建立分支并切换到该分支git branch -f &lt;new branch name&gt; &lt;commit id&gt; #在指定版本上建立分支git branch -D &lt;branch name&gt; #删除分支 修改远程分支名称一般来说，我们主要的分支都是origin，但其实这个名字是可以改的1git remote rename origin github 上传分支需改1git push &lt;remote name&gt; &lt;branch name&gt; 删除远端分支1git push &lt;remote name&gt; :&lt;branch name&gt; 查看分支12git branch #只看本地分支git branch -a #查看本地及远程分支 版本暂存12345678git stash #暂存目前修改的内容git stash list # 列出所有暂存的内容git show stash@&#123;0&#125; #显示暂存内容的详情git stash pop #取出最近一次暂存的内容git stash pop stash@&#123;n&#125; #取出指定的暂存内容git stash drop #删除暂存的内容git stash drop stash@&#123;n&#125; #删除指定的暂存内容git stash clear #清空暂存区 子模块添加子模块如果我们用到外部依赖的库的时候，通常需要使用子模块来实现 1git submodule add git@github.com:jquery/jquery.git jquery #添加jquery作为子模块 初始化子模块使用子模块的项目在clone出新的项目后，必须初始化子模块内容12git submodule initgit submodule update 在clone的时候加上--recursive可以直接完成子模块的初始化1git clone --recursive git@github.com:zlargon/git-test.git 删除子模块 删除子模块rm -rf &lt;submodule path&gt; 刪除.gitmodules 里边的submodule设置 提交修改 刪除 .git/config 里面的submodule 设置内容 刪除 .git/modules/里边的内容 参考资料 Git使用说明","categories":[{"name":"工具","slug":"工具","permalink":"https://musezhang.github.io/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://musezhang.github.io/tags/Git/"}]},{"title":"一些小技巧","slug":"some_tips","date":"2017-07-29T08:47:18.000Z","updated":"2017-07-29T09:06:52.000Z","comments":true,"path":"2017/07/29/some_tips/","link":"","permalink":"https://musezhang.github.io/2017/07/29/some_tips/","excerpt":"","text":"macos设置从终端启动sublime alias subl=\\’’/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl’\\’ 说明：其实就是设置了一个别名 to be continue……","categories":[{"name":"工具","slug":"工具","permalink":"https://musezhang.github.io/categories/工具/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://musezhang.github.io/tags/tips/"}]},{"title":"My First Hexo blog","slug":"My-First-Hexo-blog","date":"2017-07-28T16:42:08.000Z","updated":"2018-03-19T01:49:06.000Z","comments":true,"path":"2017/07/29/My-First-Hexo-blog/","link":"","permalink":"https://musezhang.github.io/2017/07/29/My-First-Hexo-blog/","excerpt":"sorry, you can't read this post!","text":"sorry, you can't read this post! Decrypt U2FsdGVkX19fVar6j/cRkNR/Qf/wdMq6dmr+ML87nqJHY+qELlQ/WwxAvDWLhMQ87ESKh13K6t7kjcYXjgA/P6sJ6uFhWazA8ZYokWHDchDE89ljpkGZHC2d4qciO/AhfrLQ3Sie1dYIUus/oHGNH1jIVEAuAPMig14nVrJN6EokxO7gxFdbIPdSesOG5+wcuE0ja8+O1KBNjnpLREioAdtKuH/EruSCQVJGpI9BDi5YnOkUzRtE0rYejG3mXUKnx45MCe2QIf/vwBsggC6sni7YJgZo0ckfgxKBSQuXMidJE59N9aFIQIDq7JaItETLppe8qbIoWBVY+mQty0Czi1n/iT1TmTmJfNNwuzmVrcOp5iikEIZdhn1XQC6YSRPnuFehWxzvc0itKC9RP9ZuPrQZpbW3hAxbApP97J5ixqsOp/XuNI3JOHatfZWR3j3rlbsPMUaf2NlfVl/O2eA3h5Kzyp4lkVQGqau3AdNiAczhw+eSrqzrrM7G650sB32DfnXKoVU5gpqbIAvTFg1wZhIIfF6ttmLHKdNVNnXtlu50gNNe1k4KATxA3Xu7/5YjyGGIPBiMPh7okowRSK7npm7MzVar8S0LrKhwFE9lmtDJgCyJc7C80jA/IydrNWnSdzZJUkFUh5MOAZ2bNYLJtOmTmcykaR+m3lUzU0fDmgaKLfqqWi5XjwJzkGWJ7Yh44FgMAFvhJUDcXYnYxrd/KUwkZrb9w2NwIaVDlhj2x0j6KdWSvdhSRsNmflr5v1qrSmsYWCHAFcGRPZ/81qf9oStlm8ZODydBcuVXrNRodba9Ka52pUtxXtALPKGWE5nojGBig/fw1CL8CPlFpH8rAvbyb5AnWZpLQx9x3/DZJGBdx+ofuS4S0+iVZFUwQ1wXlUYakqXI6ST2OwDbEmYlJuT3OGaMIEMS5jP9uQ6xJDxG/S6rNvFzWbeIH0aPSHjb2cz0Ya/OWx9W6H962eoDhfOPB4CPARAx4iDaJ7/meOnRQVwnJDZ07HfwQekNJ8+LCHDYx8c9DB/dB6btFQ3ijjJ0zQRvCpwFucYOZ2GxD4BJKTIQ3BZCoLIwt4R3j9gMNrj8o1pMIwTCNhW2M4aJgWlF7gBottEcvoeuWf7ScMlpE1YUSTBpnAnVOzUzMWxOyU2Ozf73eN2QbN1HF0skD3RUAHtz7EIxqYfcdG61Ps6yi6kUbkATeF0gaH5Jy5gY8O7BybaRL7EAdkZtYzEKnktktcrI4QVBJXtdPuKeAN0/cdfdM5GJLEuXqQ/Iz+8u66GNIJve76O2bndzFW8pBt2sQrnNV9jOgGN4vvJSvwNSR6k4UJG8xfBgrOtmYki3YJpj3eyfPxP6viKAqsfFc/6ZEcxSHHjtYuUBFJWXppoUrWBCrU/8Ky/0Rm4v64wDqTcS/UgMzz8atisf5neh6d/I1TRWvsSE7pSq+p+tT1iT1eASAr3WsM1HaT0bkJyue+j0OIkzBwV9JwxhJJ36il5D7mKXuWuL18FCVprXWRgtOMdWhqqLAHfr+XwdK+yW64UThmJRWrWSa6lKTZRBrK1uevnFF8wp1lqhW/hhPKWgpiHcn4J9xsiEwt54o5PeekbGEd9+DtHqXgByLNfCRdZD9jd7t04bHoZ8ya8kBjVfyvR5a8Qpsr6aApvyHDUb8V7+JZ961km3itNUaqvVLcxTxPhunTuMFHoOGe+XVz6zGnNNbGZc+R7YVL2sYN2T5EWIe5kch5QxjnMLfUZYttT6QMMMWISUipY/L0OWX6adygRacRa1cBZ2GRC0YfL2gqXwx8hPur9r7Gylh+SbgRk4eIMQO49S8B1ZqWy8bZ+Xlc3o5P1qwsZzhQe2TOq/nfKjZujyNuv6xspe4tSKl94krmqYa6ysA4MXwUas7YkvdClK0O9kasi/wtDwJknPF/Icy2GBZCJ3ZlG3CNXHvgUy2DQZZ2q+dODodJMO4tAE2M/lgWrY06cg/w39Ct7meSipn0mVRx38OYP7y8bLBg==","categories":[{"name":"个人生活","slug":"个人生活","permalink":"https://musezhang.github.io/categories/个人生活/"}],"tags":[{"name":"houhou","slug":"houhou","permalink":"https://musezhang.github.io/tags/houhou/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-28T16:36:58.000Z","updated":"2018-03-19T01:48:08.000Z","comments":true,"path":"2017/07/29/hello-world/","link":"","permalink":"https://musezhang.github.io/2017/07/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server123$ hexo server#debug模式$ hexo server --debug More info: Server Generate static files123$ hexo generate#缩写$ hexo g More info: Generating Deploy to remote sites123$ hexo deploy#缩写$ hexo d More info: Deployment","categories":[],"tags":[]}]}